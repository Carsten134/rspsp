% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvgridMA.R
\name{mvgridMA}
\alias{mvgridMA}
\title{Correlated MA process}
\usage{
mvgridMA(N, M, K0, K1, K0_off, K1_off, sigma)
}
\arguments{
\item{N}{`integer` First dimension of lattices}

\item{M}{`integer` Second dimension of lattices}

\item{K0}{\eqn{K_0}, numeric `matrix` used for \eqn{X_i^{(1)}} to convolute with own white noise lattice}

\item{K1}{\eqn{K_1}, numeric `matrix` used for \eqn{X_i^{(2)}} to convolute with own white noise lattice}

\item{K0_off}{\eqn{K_{0_{off}}}, numeric `matrix` used for \eqn{X_i^{(1)}} to convolute with correlated counterpart}

\item{K1_off}{\eqn{K_{1_{off}}}, numeric `matrix` used for \eqn{X_i^{(2)}} to convolute with correlated counterpart}

\item{sigma}{\eqn{\sigma}, `numeric` for correlation between whitenoise}
}
\value{
`list` object with entries X1 and X2
}
\description{
In our simulationstudy we also aim to find out how between sample correlation affects nominal size and power of our tests.
This MA-process introduces correlation on two levels: Innovations and whole lattices.
To do this, we first simulate two correlated white noise lattices \eqn{\{\epsilon_i^{(1)}|i\in \mathbb Z^2\}} and \eqn{\{\epsilon_i^{(2)}|i\in \mathbb Z^2\}}
Where:
\deqn{\begin{pmatrix}\epsilon_i^{(1)}\\ \epsilon_i^{(2)}\end{pmatrix}\overset{iid}\sim\mathcal N(0, \Sigma)}
With \eqn{\Sigma = \begin{pmatrix}1 & \sigma\\ \sigma & 1 \end{pmatrix}}

The two univariate moving average randomfieds simulated by this function are not only convoluted with their own white noise (with \eqn{K_0, K_1})
,but also their correlated counterparts (with \eqn{K_{0_{off}}, K_{1_{off}}}):
\deqn{X_i^{(1)} = \sum_{j}\epsilon_{i-j}^{(1)}K_{0,j} + \sum_l \epsilon_{i-l}^{(2)}K_{0_{off}, l}}
And analogous for \eqn{X_i^{(2)}}.
}
\examples{
K <- MA_coef_all(.7)
K_off <- K * .5

x <- mvgridMA(25, 25, K, K, K_off, K_off, .4)
par(mfrow=c(1,2))
image(x$X1)
image(x$X2)


}
